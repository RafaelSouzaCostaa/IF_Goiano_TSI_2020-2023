"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const Console_1 = tslib_1.__importDefault(require("./Console"));
const J2JError_1 = tslib_1.__importDefault(require("./J2JError"));
function formatExpectations(expectations) {
    if (!Array.isArray(expectations)) {
        expectations = [expectations];
    }
    expectations = expectations.map(expectation => {
        switch (expectation) {
            case null: return 'null';
            case String: return 'a string';
            case Array: return 'a JsonArray';
            case Object: return 'a JsonObject';
            case Number: return 'a number';
            case Boolean: return 'a boolean value';
            default: return expectation;
        }
    });
    switch (expectations.length) {
        case 0:
            throw new J2JError_1.default(null, 'QuickConsole.expectationFormatter arguemnt expectation is an empty array');
        case 1:
            return `is not ${expectations[0]}`;
        case 2:
            return `is neither ${expectations[0]} nor ${expectations[1]}`;
        default:
            const LAST_EXPECTATION = expectations.pop();
            return `is not one of ${expectations.join(', ')} or ${LAST_EXPECTATION}`;
    }
}
exports.formatExpectations = formatExpectations;
class QuickConsole {
    static warnDeprecated(emitter, fieldName, replacement) {
        Console_1.default.warn(emitter, `field '${fieldName}' is deprecated and may be removed in the future, please use '${replacement}' instead`);
    }
    static warnRemoved(emitter, fieldName) {
        Console_1.default.warn(emitter, `field '${fieldName}' had been removed in json-to-java scheme, and it will be ignored`);
    }
    static warnTypeWithReplacement(emitter, fieldName, expectations, replacement) {
        expectations = formatExpectations(expectations);
        replacement = replacement ? `value ${replacement}` : 'default value';
        Console_1.default.warn(emitter, `value of field '${fieldName}' ${expectations}, ${replacement} will be used`);
    }
    static warnIgnoreField(emitter, fieldName, expectations) {
        expectations = formatExpectations(expectations);
        Console_1.default.warn(emitter, `field '${fieldName}' will be ignored since its value ${expectations}`);
    }
    static warnElementType(emitter, fieldName, index, length, expectations) {
        expectations = formatExpectations(expectations);
        Console_1.default.warn(emitter, `value of element ${index + 1}/${length} in field \'${fieldName}\' ${expectations}`);
    }
    static warnValueTypeOfKey(emitter, fieldName, key, expectations) {
        expectations = formatExpectations(expectations);
        Console_1.default.warn(emitter, `value of key ${key} in field \'${fieldName}\' ${expectations}`);
    }
}
exports.default = QuickConsole;
