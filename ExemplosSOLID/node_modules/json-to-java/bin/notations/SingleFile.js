"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const ConvertOptions_1 = require("../utils/ConvertOptions");
const J2JError_1 = tslib_1.__importDefault(require("../utils/J2JError"));
const json_1 = require("../utils/json");
const QuickConsole_1 = tslib_1.__importDefault(require("../utils/QuickConsole"));
const Class_1 = tslib_1.__importDefault(require("./Class"));
class JavaSingleFile {
    constructor(json) {
        this.ACCEPTED_ENTRY_TYPES = ['class'];
        this.DEFAULT_DESCRIPTION_MSG = 'This java file is generated by json-to-java by ColinTree!';
        this.fileDescription = [this.DEFAULT_DESCRIPTION_MSG];
        this.package = '';
        this.imports = [];
        this.entryType = 'class';
        this.nameWhenAsEmitter = 'file root';
        // convert legacy field indentationSize into field convertOptions.indent
        if ('indentationSize' in json) {
            QuickConsole_1.default.warnDeprecated(this, 'indentationSize', 'convertOptions.indent');
            if (typeof json.indentationSize !== 'number' && json.indentationSize !== 'tab') {
                QuickConsole_1.default.warnTypeWithReplacement(this, 'indentationSize', [Number, 'string "tab"'], '4');
                json.indentationSize = 4;
            }
            json.convertOptions = (json.convertOptions || {});
            json.convertOptions.indent = json.indentationSize === 'tab' ? 'tab' : json.indentationSize;
        }
        if ('convertOptions' in json) {
            if (json_1.JsonUtil.isJsonObject(json.convertOptions)) {
                if ('indent' in json.convertOptions) {
                    if (typeof json.convertOptions.indent === 'number') {
                        ConvertOptions_1.globalConvertOptions.indent = ' '.repeat(json.convertOptions.indent);
                    }
                    else if (json.convertOptions.indent === 'tab') {
                        ConvertOptions_1.globalConvertOptions.indent = '\t';
                    }
                    else {
                        QuickConsole_1.default.warnIgnoreField(this, 'convertOptions.indent', [Number, 'string "tab"']);
                    }
                }
            }
            else {
                QuickConsole_1.default.warnIgnoreField(this, 'convertOptions', Object);
            }
        }
        if ('fileDescription' in json) {
            if (typeof json.fileDescription === 'string') {
                this.fileDescription = [this.DEFAULT_DESCRIPTION_MSG, json.fileDescription];
            }
            else if (json_1.JsonUtil.isJsonObject(json.fileDescription)) {
                this.fileDescription = lodash_1.default.merge({ '~INFO~': this.DEFAULT_DESCRIPTION_MSG }, lodash_1.default.mapValues(json.fileDescription, (value, key) => {
                    if (typeof value !== 'string') {
                        QuickConsole_1.default.warnValueTypeOfKey(this, 'fileDescription', key, String);
                    }
                    return String(value);
                }));
            }
            else if (json_1.JsonUtil.isJsonArray(json.fileDescription)) {
                this.fileDescription = lodash_1.default.concat([this.DEFAULT_DESCRIPTION_MSG], json.fileDescription.map((description, index) => {
                    if (typeof description !== 'string') {
                        QuickConsole_1.default.warnElementType(this, 'fileDescription', index, length, String);
                    }
                    return String(description);
                }));
            }
            else {
                QuickConsole_1.default.warnIgnoreField(this, 'fileDescription', [String, Object, Array]);
            }
        }
        if ('package' in json) {
            if (typeof json.package === 'string') {
                this.package = json.package;
            }
            else {
                QuickConsole_1.default.warnIgnoreField(this, 'package', String);
            }
        }
        if ('imports' in json) {
            if (json_1.JsonUtil.isJsonArray(json.imports)) {
                this.imports = json.imports.map((importElement, index, imports) => {
                    if (typeof importElement !== 'string') {
                        QuickConsole_1.default.warnElementType(this, 'imports', index, imports.length, String);
                    }
                    return String(importElement);
                });
            }
            else {
                QuickConsole_1.default.warnIgnoreField(this, 'imports', Array);
            }
        }
        // convert legacy field mainClass into field entry
        if ('mainClass' in json) {
            QuickConsole_1.default.warnDeprecated(this, 'mainClass', 'entry');
            if (json_1.JsonUtil.isJsonObject(json.mainClass)) {
                json.entryType = 'class';
                json.entry = json.mainClass;
                delete json.mainClass;
            }
            else {
                QuickConsole_1.default.warnIgnoreField(this, 'mainClass', Object);
            }
        }
        // deprecated field otherClasses
        if ('otherClasses' in json) {
            QuickConsole_1.default.warnRemoved(this, 'otherClasses');
        }
        if ('entryType' in json) {
            if (this.ACCEPTED_ENTRY_TYPES.includes(json.entryType)) {
                this.entryType = json.entryType;
            }
            else {
                QuickConsole_1.default.warnIgnoreField(this, 'entryType', this.ACCEPTED_ENTRY_TYPES.map(type => `"${type}"`));
            }
        }
        if ('entry' in json) {
            if (json_1.JsonUtil.isJsonObject(json.entry)) {
                switch (this.entryType) {
                    case 'class':
                        this.entry = new Class_1.default(0, json.entry);
                        break;
                    default:
                        // impossible since type is checked above as field
                        throw J2JError_1.default.valueNotAccepted(this, 'entryType', this.entryType);
                }
                const acceptedAccessModifier = ['public', null];
                if (!acceptedAccessModifier.includes(this.entry.accessModifier)) {
                    throw J2JError_1.default.typeError(this, 'entry.accessModifier', acceptedAccessModifier);
                }
            }
            else {
                throw J2JError_1.default.typeError(this, 'entry', Object);
            }
        }
        else {
            throw J2JError_1.default.fieldNotDefined(this, 'entry');
        }
    }
    toString() {
        return this.formatFileDescription() +
            (this.package.length > 0 ? `package ${this.package};\n` : '') +
            (this.imports.length > 0
                ? `\n${this.imports.map(importElement => `import ${importElement};`).join('\n')}\n`
                : '') +
            `${this.entry}\n`;
    }
    formatFileDescription() {
        let fileDescription = this.fileDescription;
        if (fileDescription === null) {
            return '';
        }
        if (typeof fileDescription === 'string') {
            fileDescription = [fileDescription];
        }
        let rtn = '/**\n';
        if (Array.isArray(fileDescription)) {
            fileDescription.forEach(description => {
                rtn += ` * ${description}\n`;
            });
        }
        else {
            lodash_1.default.forOwn(fileDescription, (value, key) => {
                rtn += ` * ${key}: ${value}\n`;
            });
        }
        rtn += ' */\n';
        return rtn;
    }
}
exports.default = JavaSingleFile;
